/*******************************************************************************
 * Copyright (c) 2012 - 2015 Signal Iduna Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * Signal Iduna Corporation - initial API and implementation
 * akquinet AG
 * itemis AG
 *******************************************************************************/
grammar org.testeditor.tcl.dsl.Tcl with org.eclipse.xtext.xbase.Xbase

import "http://www.testeditor.org/tcl"
import "http://www.testeditor.org/tsl" as tsl
import "http://www.testeditor.org/aml" as aml
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

TclModel:
	'package' package=QualifiedName
	(importSection=XImportSection)?
	test=TestCase;

TestCase:
	'#' name=ID
	('implements' specification=[tsl::TestSpecification|QualifiedName])?
	steps+=SpecificationStepImplementation*;

SpecificationStepImplementation:
	{SpecificationStepImplementation}
	'*' contents+=StepContent* '.'?
	contexts+=TestStepContext*;

TestStepContext:
	('Mask' | 'Component') ':' component=[aml::Component]
	steps+=(TestStep | TestStepWithAssignment | AssertionTestStep)*;

TestStep:
	{TestStep}
	'-' contents+=StepContent* '.'?;

AssertionTestStep:
	'-' 'assert' expression=AssertionExpression '.'?;

/** Assertion Exression is either a null check, 
 *  or a full comparison that requires a comparator and a right expression (in order to have no ambiguity with the null check), 
 *  or an inner expression in parenthesis (no more null checks allowed in here!) 
 */
AssertionExpression:
	AENullCheck | AEFullComparison | '(' AssertionInnerExpression ')';

/** Assertion expression that does not allow null checks */
AssertionInnerExpression returns AssertionExpression:
	AEComparison |
	'(' AssertionInnerExpression ')';

AENullCheck:
	(negated?='!')? varReference=AEVariableReference;

/** expression order: AEComparison -> (AEAddition -> AEMultiplication ->) AEValue
 *  which is reflecting the order of operator binding.
 * 
 *  for binary expression: left is always referencing the rule with higher operator binding, 
 *  right is referencing the AEInnerExpression 
 */
AEFullComparison returns AEComparison:
	left=AEValue
	comparator=Comparator
	right=AssertionInnerExpression;

AEComparison:
	left=AEValue
	(comparator=Comparator
	right=AssertionInnerExpression)?;

AEVariableReference:
	name=ID ( '.' ( key=ID | key=STRING ) )?;

AEStringConstant:
	string=STRING;

AEValue returns AssertionExpression:
	AEVariableReference | AEStringConstant;

Comparator:
	ComparatorEquals |
	ComparatorMatches |
	ComparatorLessThen |
	ComparatorGreaterThen;

ComparatorEquals:
	{ComparatorEquals} ('=' | '==' | negated?='!=' | negated?='<>' | 'is' (negated?='not')?);

ComparatorMatches:
	{ComparatorMatches} ('matches' | negated?='does' 'not' 'match');

ComparatorLessThen:
	{ComparatorLessThen} ('<' | negated?='>=');

ComparatorGreaterThen:
	{ComparatorGreaterThen} ('>' | negated?='<=');

TestStepWithAssignment:
	'-' variableName=ID '=' contents+=StepContent* '.'?;

StepContent returns tsl::StepContent:
	StepContentText | StepContentElement | StepContentVariable;

StepContentText returns tsl::StepContentText:
	value=ID | value=StepContentTextOperator;

/** hold all keywords that are allowed as step content text (to prevent parser to fail on keyword usage) */
StepContentTextOperator returns ecore::EString:
	'matches' | 'does' 'not' 'match' | 'is' 'not'?;

StepContentVariable returns tsl::StepContentVariable:
	value=STRING;

StepContentElement hidden():
	('<' value=ID '>') |
	{StepContentElement} ('<>' | '<' WS+ '>');
