/*******************************************************************************
 * Copyright (c) 2012 - 2018 Signal Iduna Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * Signal Iduna Corporation - initial API and implementation
 * akquinet AG
 * itemis AG
 *******************************************************************************/
grammar org.testeditor.tcl.dsl.Tcl with org.eclipse.xtext.xbase.Xbase

import "http://www.testeditor.org/tcl"
import "http://www.testeditor.org/tsl" as tsl
import "http://www.testeditor.org/aml" as aml
import "http://www.eclipse.org/emf/2002/Ecore" as ecore


TclModel hidden(SPACES,NL,SL_COMMENT,ML_COMMENT):
	('package' package=QualifiedName)?
	(importSection=XImportSection)?
	// TODO move require to TestCase - this should not be part of a MacroCollection
	('require' environmentVariables+=EnvironmentVariable (',' environmentVariables+=EnvironmentVariable)*)?
	(test=TestCase | macroCollection=MacroCollection | config=TestConfiguration)?;

TestCase:
	'#' name=ID
	('implements' specification=[tsl::TestSpecification|QualifiedName])?
	('config' config=[TestConfiguration])?
	( // allow user to define setup and cleanup either at the beginning or end
		(setup=TestSetup)?
	 &  (cleanup=TestCleanup)?
	 &  steps+=SpecificationStepImplementation*
	);

TestConfiguration:
	'config' name=ID
	(setup=TestSetup? & cleanup=TestCleanup?)
;

TestSetup: 
	{TestSetup}
	'Setup' ':'
	contexts+=TestStepContext*
;

TestCleanup: 
	{TestCleanup}
	'Cleanup' ':'
	contexts+=TestStepContext*
;

terminal SPACES:
	( ' ' | '\t')+
;

terminal NL:
	(( ' ' | '\t' )* ('\r'? '\n'))+  ( ' ' | '\t' )*
;

SpecificationStepImplementation hidden(SPACES):
	{SpecificationStepImplementation}
	'*' contents+=tslStepContent* nl=NL
	contexts+=TestStepContext*;

tslStepContent returns tsl::StepContent: 
	tslStepContentText | StepContentVariable;

tslStepContentText returns tsl::StepContentText:
	value=Word;

Word returns ecore::EString hidden():
	ID | StepContentTextOperator | INT | '*' | '@' | ',' | '|' | '.' | '?' | '!' | '#' | '##' | '${' | '%' | '&' | '(' | ')' | '-' | '=' | 
	'+' | '`' | '~' | '\\' | ']' | '[' | '}' | '{' | ';' | ':' | '<' | '>' | '<>' | '/' | '==' | '!=' | '>=' | '<=' | 
	'assert' | 'matches' | 'true' | "\\'" | '\\"' | '$' | '_' |
	 ANY_OTHER;

EnvironmentVariable hidden(NL,SPACES,SL_COMMENT):
	(nonConfidential?='public')?
	name=ID;

MacroCollection hidden(NL,SPACES,SL_COMMENT):
	'#' name=ID
	macros+=Macro+;

Macro hidden(NL,SPACES,SL_COMMENT):
	'##' name=ID
	'template' '=' template=Template
	contexts+=TestStepContext*
;

Template returns aml::Template hidden(NL,SPACES,SL_COMMENT):
	contents+=TemplateText (contents+=TemplateVariable contents+=TemplateText?)*	
;

TemplateText returns aml::TemplateText: 
	value=STRING
;

TemplateVariable returns aml::TemplateVariable: 
	name=TEMPLATE_VARIABLE_DEF
;

/* 
 * Using a separate terminal is required since we'd like to write ${element} and
 * this would otherwise be matched as the keyword 'element'.
 */
terminal TEMPLATE_VARIABLE_DEF:
	'${' ID? '}'
;

TestStepContext hidden (NL, SPACES, SL_COMMENT, ML_COMMENT):
	(ComponentTestStepContext | MacroTestStepContext);

ComponentTestStepContext returns TestStepContext hidden(NL, SPACES, SL_COMMENT, ML_COMMENT):
	{ComponentTestStepContext}
	('Mask' | 'Component') ':' component=[aml::Component|QualifiedName]
	steps+=(TestStep | TestStepWithAssignment | AssertionTestStep | AssignmentThroughPath)*;

MacroTestStepContext returns TestStepContext:
	{MacroTestStepContext}
	'Macro' ':' macroCollection=[MacroCollection|QualifiedName]
	steps+=TestStep*; // currently macro calls can only be TestSteps!

/**
 * keep in mind that an aml validator exists that will check templates to be parsable given the following rule
 */
TestStep hidden(SPACES, NL,SL_COMMENT):
	{TestStep}
	'-' contents+=StepContent* contents+=StepContentPunctuation?;

AssertionTestStep hidden(SPACES,NL,SL_COMMENT):
	'-' 'assert' assertExpression=(NullOrBoolCheck | FullComparison) '.'?;

TestStepWithAssignment hidden(NL,SPACES,SL_COMMENT):
	'-' variable=AssignmentVariable '=' contents+=StepContent* contents+=StepContentPunctuation?;

AssignmentThroughPath  hidden(NL,SPACES,SL_COMMENT):
	'-' variableReference=VariableReferencePathAccess '=' expression=Expression '.'?;

/** expression order: Comparison -> (Addition -> Multiplication ->) Value
 *  which is reflecting the order of operator binding.
 * 
 *  for binary expression: left is always referencing the rule with higher operator binding, 
 *  right is referencing the Expression 
 */
Expression hidden(NL,SPACES,SL_COMMENT):
	Comparison;

NullOrBoolCheck hidden(NL,SPACES,SL_COMMENT): 
	(negated?='!')? variableReference=(VariableReference | VariableReferencePathAccess);

FullComparison returns Comparison  hidden(NL,SPACES,SL_COMMENT):
	left=Value
	comparator=Comparator
	right=Expression;

Comparison hidden(NL,SPACES,SL_COMMENT):
	left=Value
	(comparator=Comparator
	right=Expression)?;

VariableReference:
	variable=[aml::Variable];
	
	
ArrayPathElement hidden(NL,SPACES,SL_COMMENT):
	'[' number=Number ']';

KeyPathElement hidden(NL,SPACES,SL_COMMENT):
	'.' ( key=ID | key=STRING );

VariableReferencePathAccess hidden(NL,SPACES,SL_COMMENT):
	variable=[aml::Variable] ( path+=KeyPathElement | path+=ArrayPathElement )+;

AtomicValue returns Expression hidden(NL,SPACES,SL_COMMENT):
	VariableReference | VariableReferencePathAccess | JsonValue ;
	
Value returns Expression hidden(NL,SPACES,SL_COMMENT):
	AtomicValue | '(' Expression ')';

Comparator hidden(NL,SPACES,SL_COMMENT):
	ComparatorEquals |
	ComparatorMatches |
	ComparatorLessThan |
	ComparatorGreaterThan;

ComparatorEquals hidden(NL,SPACES,SL_COMMENT):
	{ComparatorEquals} ('=' | '==' | negated?='!=' | negated?='<>' | 'is' (negated?='not')?);

ComparatorMatches hidden(NL,SPACES,SL_COMMENT):
	{ComparatorMatches} ('matches' | negated?='does' 'not' 'match');

ComparatorLessThan hidden(NL,SPACES,SL_COMMENT):
	{ComparatorLessThan} ('<' | negated?='>=');

ComparatorGreaterThan hidden(NL,SPACES,SL_COMMENT):
	{ComparatorGreaterThan} ('>' | negated?='<=');

AssignmentVariable:
	name=ID;
	
StepContent returns tsl::StepContent  hidden(NL,SPACES,SL_COMMENT)://; hidden(WS):
	StepContentText | StepContentElement | StepContentVariable | '@' VariableReference | '@' VariableReferencePathAccess;

StepContentText returns tsl::StepContentText:
	value=ID | value=StepContentTextOperator;

/** hold all keywords that are allowed as step content text (to prevent parser to fail on keyword usage) */
StepContentTextOperator returns ecore::EString:
	// TODO generate this (all keywords minus assert - consider Xbase keywords as well)
	'var' | 'public' | 'template' | 'package' | 'require' | 'config' | 'implements' | 'Setup' | 'Cleanup' | 
	'Mask' | 'Component' | 'Macro' | 'does' | 'not' | 'match' | 'false' | 'null' | 	
	'as' |  'is' | 'for' | 'do' | 'if' | 'while';

StepContentVariable returns tsl::StepContentVariable:
	value=STRING;

StepContentElement hidden():
	('<' value=ID '>') |
	{StepContentElement} ('<>' | '<' (SPACES | NL ) '>'); 

StepContentPunctuation hidden():
	value=('.'|'?')
;

JsonObject hidden(NL,SPACES,SL_COMMENT):
	{JsonObject}
	'{'
		(members+=JsonMember)?
		(',' members+=JsonMember)*
	'}';

JsonMember hidden(NL,SPACES,SL_COMMENT):
	key=STRING ':' value=JsonValue;

JsonValue hidden(NL,SPACES,SL_COMMENT):
	JsonString | JsonNumber | JsonObject | JsonArray | JsonBoolean | JsonNull;

JsonString:
	value=STRING;

JsonBoolean:
	value=Boolean;

JsonNull:
	{JsonNull}
	'null';

JsonArray hidden(NL,SPACES,SL_COMMENT):
	{JsonArray}
	'['
		(values+=JsonValue (',' values+=JsonValue)*)?
	']';

JsonNumber:
	value=JsonDecimal;

Boolean returns ecore::EBoolean:
	'true' | 'false';

JsonDecimal returns ecore::EString hidden():
	'-'? Number;
